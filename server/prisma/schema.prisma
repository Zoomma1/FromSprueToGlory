// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ—„ï¸ Prisma Schema â€” From Sprue to Glory
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This file defines ALL database tables, relationships, and enums.
//
// KEY CONCEPTS:
//   - Each `model` = one database table
//   - `@relation` = defines foreign key relationships
//   - `@@index` = database index for faster queries
//   - `enum` = constrained set of values (like TypeScript union types)
//
// WHY Prisma?
//   - Type-safe database queries (no raw SQL mistakes)
//   - Auto-generated TypeScript types (shared with our code)
//   - Easy migrations (schema changes â†’ SQL automatically)
//   - ALTERNATIVE: TypeORM (more flexible but less type-safe, more boilerplate)
//
// ğŸ¯ MINI-EXERCISE: Add a new field `priority` (Int, optional) to the Item model.
//    Then run `npx prisma format` to auto-format the schema.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” AUTH â€” User accounts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations: a user "owns" items, color schemes, projects, and refresh tokens
  items         Item[]
  colorSchemes  ColorScheme[]
  projects      Project[]
  refreshTokens RefreshToken[]

  @@map("users") // table name in PostgreSQL
}

model Project {
  id          String   @id @default(uuid())
  userId      String
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  items Item[]

  @@index([userId])
  @@map("projects")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“š REFERENCE DATA â€” Game Systems, Factions, Models
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// These tables are "read-mostly": seeded at startup, rarely changed by users.

model GameSystem {
  id   String @id @default(uuid())
  name String @unique
  slug String @unique // URL-friendly name: "40k", "aos", "kill-team"

  // Relations
  factions     Faction[]
  items        Item[]
  colorSchemes ColorScheme[]

  @@map("game_systems")
}

model Faction {
  id           String @id @default(uuid())
  name         String
  gameSystemId String

  gameSystem   GameSystem @relation(fields: [gameSystemId], references: [id])

  // Relations
  models       Model[]
  items        Item[]
  colorSchemes ColorScheme[]

  @@unique([name, gameSystemId]) // no duplicate faction names within a game system
  @@index([gameSystemId])
  @@map("factions")
}

model Model {
  id         String @id @default(uuid())
  name       String
  factionId  String
  pointsCost Int?   // optional points value

  faction Faction @relation(fields: [factionId], references: [id])
  items   Item[]

  @@unique([name, factionId]) // no duplicate model names within a faction
  @@index([factionId])
  @@map("models")
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ PAINTS & TECHNIQUES â€” Painting reference data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

model PaintBrand {
  id   String @id @default(uuid())
  name String @unique
  slug String @unique // "citadel", "vallejo", "army-painter"

  paints Paint[]

  @@map("paint_brands")
}

enum PaintType {
  BASE
  LAYER
  SHADE       // wash
  DRY
  CONTRAST
  TECHNICAL
  AIR
  METALLIC
  INK
  PRIMER
  VARNISH
  TEXTURE
  OTHER
}

model Paint {
  id      String    @id @default(uuid())
  name    String
  code    String?   // product code (e.g., "21-25")
  brandId String
  type    PaintType @default(OTHER)
  notes   String?

  brand PaintBrand @relation(fields: [brandId], references: [id])

  // Used in color scheme steps
  colorSchemeSteps ColorSchemeStep[]

  @@unique([name, brandId]) // no duplicate paint names within a brand
  @@index([brandId])
  @@map("paints")
}

model Technique {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?

  // Used in color scheme steps
  colorSchemeSteps ColorSchemeStep[]

  @@map("techniques")
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ ITEMS â€” The Pile of Shame
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum ItemStatus {
  WANT
  BOUGHT
  ASSEMBLED
  WIP
  FINISHED
}

model Item {
  id             String     @id @default(uuid())
  userId         String
  name           String
  gameSystemId   String
  factionId      String
  modelId        String?    // optional: not all items map to a specific model/unit
  points         Int?
  quantity       Int        @default(1)
  purchaseDate   DateTime?
  price          Float?
  currency       String     @default("EUR")
  store          String?
  notes          String?
  tags           String[]   // PostgreSQL array â€” flexible tagging
  status         ItemStatus @default(WANT)
  colorSchemeId  String?
  projectId      String?
  photoKey       String?    // S3 object key (NOT a public URL)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  // Relations
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  gameSystem     GameSystem  @relation(fields: [gameSystemId], references: [id])
  faction        Faction     @relation(fields: [factionId], references: [id])
  model          Model?      @relation(fields: [modelId], references: [id])
  colorScheme    ColorScheme? @relation(fields: [colorSchemeId], references: [id], onDelete: SetNull)
  project        Project?    @relation(fields: [projectId], references: [id], onDelete: SetNull)

  // Status change history
  statusHistory  ItemStatusHistory[]

  @@index([userId])
  @@index([status])
  @@index([gameSystemId])
  @@index([factionId])
  @@index([projectId])
  @@map("items")
}

// â”€â”€â”€ Status History (auto-populated on status change) â”€â”€â”€â”€
model ItemStatusHistory {
  id         String     @id @default(uuid())
  itemId     String
  fromStatus ItemStatus
  toStatus   ItemStatus
  changedAt  DateTime   @default(now())

  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([itemId])
  @@index([changedAt])
  @@map("item_status_history")
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ COLOR SCHEMES â€” Painting recipes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

model ColorScheme {
  id                String   @id @default(uuid())
  userId            String
  name              String
  gameSystemId      String?
  factionId         String?
  description       String?
  referencePhotoKey String?  // S3 object key
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  gameSystem GameSystem? @relation(fields: [gameSystemId], references: [id])
  faction    Faction?    @relation(fields: [factionId], references: [id])

  // Steps: the ordered painting recipe
  steps ColorSchemeStep[]

  // Items using this scheme
  items Item[]

  @@index([userId])
  @@map("color_schemes")
}

// â”€â”€â”€ Color Scheme Steps (ordered painting instructions) â”€â”€
model ColorSchemeStep {
  id             String  @id @default(uuid())
  colorSchemeId  String
  orderIndex     Int     // 1-based, unique per scheme
  area           String  // "Armor", "Trim", "Weapon", "Base", etc.
  techniqueId    String
  paintId        String? // optional: some steps don't use a specific paint
  mix            String? // e.g., "2:1 Paint:Medium" or JSON
  dilution       String? // e.g., "thin", "heavy", "milk consistency"
  tools          String? // e.g., "size 1 brush", "sponge", "airbrush"
  notes          String?
  expectedResult String? // e.g., "smooth dark blue base"

  // Relations
  colorScheme ColorScheme @relation(fields: [colorSchemeId], references: [id], onDelete: Cascade)
  technique   Technique   @relation(fields: [techniqueId], references: [id])
  paint       Paint?      @relation(fields: [paintId], references: [id])

  @@unique([colorSchemeId, orderIndex]) // enforce unique order within a scheme
  @@index([colorSchemeId])
  @@map("color_scheme_steps")
}
